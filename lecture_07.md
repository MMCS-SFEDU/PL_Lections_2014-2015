# Лекция 7

## Стандартные функции для работы с C-строками

```cpp
#include <cstring>

// Возвращает длину строки p
size_t strlen(const char* p){...}

// Копирует строку q в строку p 
char*  strcpy(char* p, const char* q){...}
// Возвращает указатель на последний символ скопированной строки

// Сравнение строк в лексико-графическом порядке
size_t strcmp( const char* s1, const char* s2);
// <0, s1 < s2
//  0, s1 == s2
// >0, s1 > s2

// Добавляет s2 в конец s1
int strcat(char* s1, const char* s2);
// Считается, что в строке s1 достаточно памяти

// Ищет в строке s символ с
char* strchr(const char* s, char c));

// Ищет в строке s подстроку s1
char* strstr(const char* s, const char* s1);
```

### Контроль памяти при работе с этими функциями

```cpp
char* s1 = "Hello";
char s1[] // Указатель объявляется как не исменяемый
char* s2;

strcpy(s2, s1); // Это работать не будет

char s2[4];
strcpy(s2, s1);
```

Контроль памяти лежит на программисте, в случае ошибки она  по-началу может себя никак не проявить.

Обычно не пользуются такими опасными функциями. Вместо них используют аналогичные функции, контролирующие размер записываемых данных.

```cpp
strncpy(s2, s1, 4);
// Защищает от переполнения
```


## Указатели и динамическая память

В C/С++ динамическая память управляется с помощю указателей.

**Замечание.** В С++ сборщика мусора нет!!! Ответственность за выделение и освобождение памяти лежит на программисте.

```cpp
int* pi;
```

Если мы хотим в динамической памяти выделить место для `int`

```cpp
pi = new int;

// Короче
int* pi = new int;
*pi = 5;
(*pi)++; // (*pi) == 6
```

Освобождене памяти:

```cpp
delete pi;
pi = nullptr;
```

### Ошибки при работе с динамической памятью

1 . Попытка разыменования нулевого указателя

```cpp
	int *pi;

	*pi = 5;
	// Программа сразу рухнет
```

2 . Утечка памяти

```cpp

int *pi = new int;
pi = new int;
for(;;)
  pi = new int;
```

2a .

```cpp
void f()
{
  int* pi = new int;
}
```

3 . Обращение к освобожденной памяти

```cpp
int *pi = new int;
*pi = 5
delete pi;
*pi = 6;
```

## Массивы в динамической памяти(динамические массивы)

```cpp

int* pi new int[10]; // Выделение памяти для 10 элементов

pi[0] = 5;
pi[1] = 3;
...
```

Для возврата этой памяти используется оператор `delete[]`:

```cpp
delete[] pi;
```

**Примечание.** Обычно менеджер динамической памяти размещает в отрицательных адресах массива размер выделенной памяти, однако использовать эту информацию, скорее всего, не удастся.


### Как передавать динамические массивы в функции

```cpp
void print(const int* pi, int size)
{
  for(int i = 0; i < n, i++)
    cout << pi[i] << ' ';
}

int* pi = new int[10];
print(pi, 10);
```

## Двумерные динамические массивы 


Для статических массивов

```cpp
int a [3][4]; // размеры это константы, поскольку память должна выделяться на этапе компиляции

void f(int a[][4], int m, int n)
{
  ...
}
```

Вообще говоря. так писать плохо. В таких случаях лучше использовать двумерные динамические массивы.

Выделение памяти длядинамического массива

```cpp
int** a; // a - указатель на начало массива из int*

int m, n;
cin >> m >> n; // Здесь размеры определяются на этапе выполнения программы
a = new int*[m];
```

Каждый элемент имеет тип `int*`  и значение `NULL`.

```cpp
for(int i = 0; i < m; i++)
  a[i] = new int[n];

// Теперь можно обращаться
a[1][2] ~ *(*(a+1)+2)
```

### Передача двумерного динамического массива в функции

```cpp
void print(const int** a, int m, int n)
{
  for(int i = 0; i < m; i++)
  {
    for(int j = 0; i < n; j++)
      cout << a[i][j] << ' ';
    cout << endl;
  }
}
```

Двумерный **статический** массив в эту функцию передать нельзя.


**Замечание.** Динамические массивы позволяют задавать свой назмер во время выполнения программы.


### Возврат памяти

```cpp
for(int i = 0; i < m; i++)
  delete[] a[i];
delete[] a;
```

## Динамические структуры данных

#### Линейный односязный список

```cpp
struct node
{
  int dat;
  node* next;
  node(int data, node* next)
  {
    // this указатель на себя
    this->data=data;
    this->node=next;
  }
};
```
В С++ объект вызова конструктора не содержится в динамической памяти.

```cpp
node n1 (4, nullptr);
```

Память под `n1` выделяется на стеке самой программы, а конструктор лишь инциализирует поля.

```cpp
node n2(3, &n1);
node n3(5, &n2);

node* p = &n3;
```

## Шаблоны структур

Шаблоны впервые появились в C++, затем они перекочевали в  других языках программирования

```cpp
template<typename T>
struct node
{
  T dat;
  node<T>* next;
  node(T data, node<T>* next)
  {
    // this указатель на себя
    this->data=data;
    this->node=next;
  }
};

...

node<int>(4, nullptr);
```


