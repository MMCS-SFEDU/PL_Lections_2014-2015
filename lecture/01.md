---
layout: default
---

# Лекция 1



<a id="history_c_plus_plus" title="История C++" class="toc-item"></a>
## История C++



##### Основные вехи развития:

1. 1972 — создание языка С (Брайан Керниган, Деннис Ритчи)
2. 1980 — создание языка С++ (Бьярн Страуструп)
3. 2003 — принят первый стандарт языка C++
4. 2011 — принят [второй стандарт](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf) языка C++

##### Философия С++

* Эффективность (в ущерб безопасности: например, 
	нет контроля выхода за пределы массива)
* Переносимость
* Мультипарадигмальность



<a id="simplest_program" title="Простейшая программа" class="toc-item"></a>
## Простейшая программа



Каждая программа на C++ состоит из одной или более функций. Среди них *обязательно* должна присутствовать главная функция `main`, которую и вызывает операционная система при запуске программы. Простейший пример:

```cpp
int main() {
    return 0;
}
```

Значение, возвращаемое `main`, используется ОС для определения успешности
завершения программы. Если не ноль, то в программе произошла ошибка.

```cpp
#include <iostream>   // Заголовочный файл

int main() {
    std::cout << "Hello world!" << std::endl;
}
```


<a id="namespaces" title="Пространства имен" class="toc-item"></a>
## Пространства имен



Чтобы каждый раз не писать префикс `std::`, можно включить пространство 
имён в глобальную область видимости:

```cpp
using namespace std; // Всё содержимое пространства std 
                     // становится видимым во всем файле.
                     
using std::cout;     // Либо только элемент cout становится
                     // видимым во всем файле.

int main() {
    cout << "Hello world!";
}
```



<a id="data_types" title="Типы данных" class="toc-item"></a>
## Типы данных



| С++           | Pascal      |
| ------------- |-------------|
| int           | integer     |
| bool          | boolean     |
| double, float | real        |
| char          | char        |

Замечание: в типе `char` не поддерживается Unicode по умолчанию.



<a id="ways_to_initialize_variables" title="Способы инициализации переменных" class="toc-item"></a>
## Способы инициализации переменных



```cpp
double d = 3.14;    // старый стиль

double d {3.14};    // новый стиль
double d = {3.14};  // или так
```



<a id="implicit_type_conversion" title="Неявное преобразование типов" class="toc-item"></a>
## Неявное преобразование типов



В C++ при попытке присвоить целочисленной переменной значение с плавающей 
точкой, произойдёт **отбрасывание** дробной части. При инициализации в новом 
стиле будет ошибка компиляции.

```cpp
int i = 3.14;   // i == 3
int i {3.14};   // Ошибка компиляции
```

Тип `char` занимает 1 байт, поэтому диапазон его значений [-128,127], 
однако следующий код будет откомпилирован.

```cpp
char c = 128;   // c == -128
```



<a id="basic_operations" title="Основные операции" class="toc-item"></a>
## Основные операции



| C++ | Pascal |  Примеры |
|:---:|:------:|:--------:|
| =   | :=     | `int a = 4;`
|  /  | div    | `7 / 3` — тип `int`;   `7 / 3.0` — `double`
|  %  | mod    |
| a++ / ++a| a = a + 1 | ...
|||
| &&  | and    |  `i > 0  &&  i != 2`
|\|\| | or     |  `i == 4  ||  i == 5`
| !   | not    |
| ==  | =      |
| !=  | <>     |
|||
| <<  | shl    | `(8 << 1  =  16)` 
| >>  | shr    |
| &   | and    | `7 & 3 == 3`
|  \| | or     |
| ^   | xor    |
| ~   | not    |

Возможна запись `a = b = c`, означающая `b = c; a = c` — множественное присваивание (справа налево).

Особое внимание стоит обратить на операцию сравнение на равенство:

```cpp
if (a = 5)  …  // (1) Неверно! Но легко пропустить
if (5 = a)  …  // (2) Неверно! И компилятор выдаст ошибку

if (a == 5) … // (3) Верно! Но если спутать с (1), то легко не заметить
if (5 == a) … // (4) Верно! И если спутать с (2), то легко увидеть: ошибка компиляции
```



<a id="conditional_operator" title="Условный оператор" class="toc-item"></a>
## Условный оператор



```cpp
if (условие) {
    ...
} else {
    ...
}
```
Допускается сокращённая форма (без `else`).



<a id="ternary_conditional_operator" title="Тернарная условная операция" class="toc-item"></a>
### Тернарная условная операция



```cpp
bool flag;
if (flag) {
    cout << "true";
} else {
    cout << "false";
}
```

Более короткая запись:

```cpp
cout << (flag ? "true" : "false");
```



<a id="choice_operator" title="Оператор выбора" class="toc-item"></a>
## Оператор выбора



```cpp
switch (i) {
    case 1:
        ...
        break;
    case 2:
    case 3:     
    ...
    default:
}
```



<a id="looping" title="Операторы цикла" class="toc-item"></a>
## Операторы цикла





<a id="while_loop" title="Цикл while" class="toc-item"></a>
### Цикл `while`



```cpp
while (x > 10) {
    x -= 1;
}
```



<a id="do_while_loop" title="Цикл do-while" class="toc-item"></a>
### Цикл `do-while`



```cpp
do {
   x--;
} while (x > 0);
```
Похож на `repeat/until` в Паскале, но используется условие продолжения 
цикла (как в `while`), а не условие окончания как в `repeat/until`.



<a id="for_loop" title="Цикл for" class="toc-item"></a>
### Цикл `for`



```cpp
for (инициализация; условие_продолжения; действие_на_каждом_шаге) {
    ...
}

for (int i = 0; i < 10; i++) {
    cout << i << " ";
}								// "0 1 2 3 4 5 6 7 8 9 "

for (;;);  // бесконечный цикл
```



<a id="operator_comma" title="Оператор , (запятая)" class="toc-item"></a>
## Оператор `,` (запятая)



Возвращает значение своего последнего операнда, например:

```cpp
int s = 0, i = 6;
cout <<  s = i*i, i;  // Выведет 6
```
