---
layout: default
---

<!-- 
WARNING!!!
This file was generated automatically.
All changes made here will be erased.
-->

<script type="text/javascript">var last_page = true</script>

# Лекция 20

Рассмотрим другой `for_each`. Сначала напишем такую функцию:

```cpp
void twice (int & x)
{
	x *= 2;
}
``` 
```cpp
for_each(begin(v), end(v), twice)
// с помощю лямбд
for_each(begin(v), end(v), [](int& x){x *= 2;})
```

Теперь нам нужен `for_each`, который будет умножать элементы контейнера на произвольное число.



<a id="capture_variables_from_external_context" title="Захват переменных из внешнего контекста" class="toc-item"></a>
## Захват переменных из внешнего контекста



Изменим код `for_each` следующим образом:

```cpp
for_each(begin(v), end(v), [](int& x){x *= a;})
```

Для того, что бы такой код компилировался нам необходимо указать в списке захвата, что переменная `a` пришла в функцию извне

```cpp
int a = 5;
for_each(begin(v), end(v), [=a](int& x){x *= a;})
```

Так же в списке захвата можно использовать `[=]` ― таким образом указывается, что все переменные, которые встретятся в теле лямбда функции, захватываются по значению.

**Примечание.** Лучше, если описание `int a` будет находится близко к вызову `for_each`




<a id="sum_of_elements_of_container_using_for_each" title="Сумма элементов контейнера с помощью for_each" class="toc-item"></a>
## Сумма элементов контейнера с помощью `for_each`



```cpp
int sum = 0;
for_each(begin(v), end(v), [&sum](int x){sum += x;})
```

Как видим в списке захвата появилась ссылка, поэтому теперь изменение `sum` в функции будет изменять значение этой переменной.

`[&]` - все переменные в теле лямбда, не являющиеся параметрами, захватываются по ссылке.

`[&, =x]` - все переменные в теле лямбда, кроме `x`, не являющиеся параметрами, захватываются по ссылке.

`[=, &sum]` - все переменные в теле лямбда, кроме `sum`, не являющиеся параметрами, захватываются по значению.




<a id="objects_function_functors" title="Объекты функции (функторы)" class="toc-item"></a>
## Объекты функции (функторы)



На самом деле в C++ лямбда выражения являются синтаксическим сахаром. В действительности лямбда функции с захваченными переменными переводятся объекты функций.

Создадим следующий класс:

```cpp
class SimHelper
{
public:
	int sum;
	SumHelper(): sum(0) {}
	void operator()(int x)
	{
		sum += x;
	}
}
```

На самом деле `f` в теле `for_each` это экземпляр класса, у которого перегружен `operator()`, а не функция, как может подумать неопытный разработчик:

```cpp
auto f = for_each(begin(v), end(v), SumHelper())
cout << f.sum;
```

**Объектом функции** называется объект класса с перегруженной операцией `operator()`.




<a id="assigning_variable_lambda_funcs" title="Присваивание лямбда функций переменной" class="toc-item"></a>
## Присваивание лямбда функций переменной



```cpp
#include <functioanal>

auto g = [](int x){return x*x;}
// Здесь auto принимает тип std::function<int(int)>, поэтому можно написать так:
// std::function<int(int)> g = [](int x){return x*x;}
cout << g(5);
```



<a id="types_of_iterators" title="Виды итераторов" class="toc-item"></a>
## Виды итераторов



* `InIt`
<br>&nbsp;&nbsp;&nbsp;&nbsp; ∩
* `OutIt`
* `FwdIt`
<br>&nbsp;&nbsp;&nbsp;&nbsp; ∩
* `BidIt`
<br>&nbsp;&nbsp;&nbsp;&nbsp; ∩
* `RanIt`

Со всеми итераторами можно совершать следующие действия:

* `it1 == it2`, `it1 != it2`
* `it++`, `++it`
* `a = *it`

В `BidIt` добавлены возможности:

* `it--`, `--it`

C `RanIt` допустимы те же операции, что и с `BidIt` плюс:

* `it[i]`
* `it1 < it2`, `it1 > it2`
* `it2 - it1 = n`
* `it + n`, `it - n`

Важно понимать, что название итератора это только договоренность, принятая в языке.




<a id="algorithm_find" title="Алгоритм find" class="toc-item"></a>
## Алгоритм `find`



Работа:

```cpp
template<typename InIt, typename T>
InIt find(InIt b, InIt e, T t)
{
	while(b != e)
		if(*b == t)
			return b;
		++b;
	return b;
}
```

Использование:

```cpp
int a[]{3, 1, 5, 7}
auto it = find(begin(a), end(a), 5)
if (if != end(a))
	cout << "нашли" << *it;
else cout << "Нет";
```




<a id="algorithm_find_if" title="Алгоритм find_if" class="toc-item"></a>
## Алгоритм `find_if`



Работа:

```cpp
template<typename InIt, typename Pred>
InIt find_if(InIt b, InIt e, Pred p)
{
	while(b != e)
		if(p(*b))
			return b;
		++b;
	return b;
}
```

Предикат это то, что может быть вызвано с одним параметром и вернет `bool`.


Использование:

```cpp
int a[]{3, 1, 5, 7}
auto it = find_if(begin(a), end(a), [](int x)->bool{return x%2 == 0})
if (if != end(a))
	cout << "нашли" << *it;
else cout << "Нет";
```