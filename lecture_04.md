#Лекция 4


##Precompiled headers

В режиме включенных предкомпилированных заголовков при компиляции заголовочных файлов все они попадают в откомпилированном виде в файл **.pch**, тогда при необходимости оне не компилируются повторно, а берутся из **.pch**. Это приводит к уменьшению времени компиляции в **больших проектах**, поэтому  


##Перечисления

###Перечиления в C++98

Пречисления, согласно стандарту C++98, объявляются следующим образом:

	enum DayOfWeek {MON, TUE, WED, THU, FRI, SAT, SUN};

Каждый элемент перечисления это целое число: MON = 0, TUE = 1, ... . При этом существует возможность явно задавать значения элементов enum. Например:

	enum DayOfWeek {MON, TUE = 3, WED, THU, FRI, SAT, SUN};

Тогда MON = 0, TUE = 3, WED = 4, ... .

Благодаря тому, что все имена перечисления являются целыми числами возможно следующее присваивание:

	int day = MON; // ошибки не произойдет day == 0;
	DayOfWeek dow = 5 // а здесь произойдет ошибка во время компиляции            


###Перечиления в C++11

При объявлении enum все имена перечисления экспортируются во внешнюю обасть видимости, это приводит к проблеме коллизии имен в крупных проектах. Для решения данной проблемы в C++11 был введен *enum class*. **enum class** – это строго типизированные перечисления с ограниченной областью видимости. Объявление enum class происходит следующим образом:

	enum class DayOfWeek {MON, TUE, WED, THU, FRI, SAT = 6, SUN};

При этом особенности работы с ним следующие:

	// Ошибка при преобразовании DayOfWeek к int
	int day = DayOfWeek::WED;
	// Ошибка: WED нет в облати видимости
	int wday = WED;
	// Присваение переменной значения из множества имен перечисления DayOfWeek
	DayOfWeek dow = DayOfWeek::FRI;
	// При необходимости присваивания переменной типа DayOfWeek целого числа
	// можно воспользоваться оператором static_cast<type> (object);
	DayOfWeek sat = static_cast<DayOfWeek> (6);

### Использование перечислений

Часто имена перечислений используются в операторе swith()

	switch(dayOfWeek){
	  case DayOfWeek::MON: cout << "Monday\n"; break;
	  case DayOfWeek::TUE: cout << "Tuesday\n"; break;
	  case DayOfWeek::WED: cout << "Wedesday\n"; break;
	  case DayOfWeek::THU: cout << "Thusday\n"; break;
	  case DayOfWeek::FRI: cout << "Friday\n"; break;
	  case DayOfWeek::SAT: cout << "Satuday\n"; break;
	  case DayOfWeek::SUN: cout << "Sunday\n"; break;
	}



## Массивы 

#####Особенности массивов в С/C++:

* элементы массивов индексируются с нуля
* нет контроля выхода за пределы массива
* высокая скорость работы с массивом (как следствие предыдущего)
* массив не хранит свой размер 


#####Работа с массивами C/C++:

	// Создание массива из 5 элементов типа int
	int arr[5]; 
	// Создание и инициализация массива из 4 элементов 
	int arr2[] = {2, 3, 5, 7};
	// Запись в 3 элемент масива
	arr[3] = 1;
	// Вывод элемента массива
	cout << arr[2];


Т.к массивы в C/C++ не помнят своего размера, то его необходимо определять вручную след образом:

	int size = sizeof(arr2)/sizeof(int) - 1;
	// sizeof(arr2) возвращает размер массива в байтах
	// sizeof(int) возвращает размер элемента массива


### Цикл по массиву (foreach)

	int a[] = {3, 7, 9, 5, 7, 2, 7};

	for(int xx:a)    // Доступ к xx 
		cout << xx;  // есть только на чтение

	for(int &x:a)    // x передается по ссылке, поэтому
		cout << xx;  // доступ есть на чтение и на запись

### Передача массива в функцию

В C/C++ массив **всегда** передается по ссылке, поэтому использование оператора **sizeof()**, для определения его размера, бесполезно. Потому при передаче массива в функцию вместе с ним передается и его размер.

	const int n;
	int a[n] = {1, 3, 5, 6, 1};

	...

	void f(int a[], int n){
	  ...
	}

	...

	f(a, n);


## Строки в стиле C

В С строки определяются как одномерный массив типа **char**.

	char str[] = "Hello world!!!"
	// Это строка из 14 символов, однако размер массива будет равен 15
	// т.к строки в C заканчиваются символом '\0' - нуль терминатор,
	// поэтому такие строки иногда называют нуль-терминированными

При попытке стандартным образом ввести с консоли значение *"Hello world!!!"* в **str**, будет введено только *"Hello"*. Чтобы этого не проиходило необходимо использовать следующую запись:

	std::cin.getline(str, 14); // 14 - количество вводимых символов
