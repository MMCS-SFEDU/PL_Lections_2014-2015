# Лекция 10


## Конструктор со списком инициализации.

В 9 лекции рассматривался следующий пример конструктора класса `Date`

```cpp
Date(int d, int m, int y)
{
  this->d = d;
  this->m = m;
  this->y = y;
}
```

Данная реализация непрофессиональная. 
Такой конструктор выполняет двойную работу.
Сначала выполняется инициализация "нулевыми" значениями, а за тем выполняется тело конструктора.
Поэтому лучше делать конструктор со списком инициализации.


```cpp
Class Date {
  int d, m, y;
  
  public:
  Date(int d, int m, int y) : d(d), m(m), y(y) {}
};
```

Здесь.
`d(d), m(m), y(y)` - список инициализации

// d(d), m(m), y(y) - список инициализации, а конструкция `d(d)` означает  `поле(аргумент конструктора)`

Для больших классов обычно разносят описание и реализацию всех функций-членов в `*.h` и `*.cpp`, для улучшения обозримости класса.
 

## Перегрузка операций

Как было сказано на прошлой лекции бинарные операции можно перегружать двумя способами: как функцию-член и как внешнюю функцию.
При перегрузке бинарного оператора, очень важно правильно ответить на вопрос: как выбрать между функцией-членом и внешней функцией?. 
Ключевым моментом этого выбора является то, что функция-член имеет доступ в внутренним полям класса.


### Перегрузка операции сравнения на равенство

Рассмотрим перегрузку операции сравнения на равенство на примере класса `Date` из 9 лекции.

```cpp
Class Date
{
  int d, m, y;

  publuc:
    //bool operatot==(Date d1, Date d2) типичная ошибка
    bool operator==(Date const & other)
    {
      return d == other->d &&  
             m == other->m &&
             y == other->y &&
    }
};
```

**Заметим.** Если операция бинарная, то у нее будет один аргумент (в случае когда операция определена функцией-членом). 
Если класс этого аргумента совпадает с текущим классом, то у нас есть доступ к закрытой части класса.

Аргумент оператора правильнее передавать по ссылке на константу. 
Вообще говоря, это **общее правило C++**: сначала формальный аргумент описывается как ссылка на константу, затем, при необходимости, снимается константность этого аргумента и передача по ссылке заменяется передачу самого объекта. 


### Перегрузка операции вывода в поток (чтения из потока)

Должен ли `operator<<(>>)` быть функцией-членом? 
Ответ: нет, он должен быть внешней функцией т.к `cout` - объект существующего класса.

Если `operator<<(>>)` должен быть внешней функцией, тогда как получить доступ к полям класса `Date`? 
Для решения это проблемы, обычно, `operator<<` объявляется "другом" класса (помещается в область `friend:`).

`operator<<` должен возвращать `cout` для допустимости цепочек типа `cout << d1 << d2;`

```cpp
/* date.h */
Class Date {
  int d, m, y;
public:
  
  ...

friend:
  ostream & operator<<(ostream & os, Date const & d);      
};


/* date.cpp */
ostream & operator<<(ostream & os, Date const & d)
{
  os << d.d << '.' << d.m << '.' << d.y << std::endl;
  return os;
}
```

Операция чтения из потока определяется аналогичным образом, только вместо `ostream` используется `istream`.

Операторы `operator<<` и `operator>>` всегда возвращают ссылку на поток.


#### Более короткий вариант

Т.к. `operator<<` очень небольшой, то его лучше сделать `inline`. Перенесем реализацию оператора в заголовочный файл.

```cpp
/* date.h */
Class Date {
  int d, m, y;
public:
  
  ...

friend:
  ostream & operator<<(ostream & os, Date const & d);      

  ostream & operator<<(ostream & os, Date const & d)
  {
    os << d.d << '.' << d.m << '.' << d.y << std::endl;
    return os;
  }
};
```

Если **friend** определен прямо в классе, то он остается внешней функцией и становится inline.


### Перегрузка арифметических операций.


#### Канонический вид перегрузки арифметических операций.

Пусть `@` ∈ {`+`, `-`, `*`, `/`}.
Обычно определяют пару функций: `operator@=`, `operator@`.
В таком случае `operator@=` объявляется как функция-член, а  `operator@` как внешняя функция.

`operator@=` - это присваивающая версия оператора.

Рассмотрим перегрузку арифметических операций на примере другого класса `BigInteger`

```cpp
class BigInteger
{
  int data[1024];

public: 
  BigIntiger & operator+=(BigInteger cons & other)
  {
    // Цикл по data
  }
};

// Ссылки здесь нет, 
// т.к мы не можем возвращать ссылку на локальные переменные.
BigInteger operator+(BigInteger const & bi1, BigInteger const & bi2)
{
  BigInteger res(bi1); // копия a
  res += bi2; // res хранит bi1 + bi2
  return res;
}
```

Учитывая, что `@=` - `inline`, дополнительных расходов на ее вызов не возникает.


### Перегрузка унарных операций

Т.к. у унарной операции только один аргумент - `this`, то унарный оператор должен быть реализован, как функция-член и возвращать ссылку на себя.

```cpp
class Date
{
  ...
  // определение префиксного ++
  Date operator++()
  {
    ...
    // Возвращаем ссылку на себя
    return *this;
  }
};
```

