## Downcast

Пусть в классе `Student` есть функция `get_group()`, которая возвращает номер группы студента. Напомним, что её нет в `Person`.

```cpp
/* Student.h */
class Student : public Person
{
    int group;

public:
    int get_group() const
    {
        return group;
    }
};
```

Теперь рассмотрим следующую ситуацию:
```cpp
Person *p = new Student('Иванов', 20, 2, 9);
p -> get_group();  // error
```

Получаем ошибку компиляции, так как в `Person` не определна функция
`get_group()`. Нужно привести `p` к типу `Student`.

```cpp
// Старый стиль:
((Student*)pp) -> get_group;

// Совеременный стиль:
static_cast<Student*>(pp) -> get_group();
```

Другая ситация:

```cpp
Person & rp = *new Student("Петров", 20, 2, 9);
static_cast<Student &>(rp).get_group();
delete &rp;
```

## Полиморфизм

> Полиморфизм в C++ работает **только** через указатель или ссылку на объект базового класса.

```cpp
Student s("Иванов", 20, 2, 9);
Person * pp = &s;
pp -> Print();
```

Если `print()` не вертуальная, то происходит *раннее связывание* имени метода `print()` с конкретным типом. То есть сейчас вызовется Person.print().


... # Пропустил главу


## Деструкторы и полиморфизм

Как работает **new**: сначала выделяется память, потом вызывается конструктор. <br>
Как работает **деструктор**: сначала вызывается деструктор, потом возрващается память.

```cpp
Person * pp = new Student("Иванов", 20 2, 9);
pp -> Print();
delete pp;
```

В данном случае вызовётся `~Person()`. Деструкторы тоже могут виртуальными, но по умолчанию — нет. Что делать? Написать виртуальный деструктор. 

```cpp
class Person
{
    ...
    virtual void Print() { ... }
    virtual ~Person() { ... }
}
```

Теперь вызовется `~Student()`.

Для класса Student, если не написать деструктор, то он сгенерируется автоматическим и будем виртуальным.

> **Правило**: Если в классе есть хотя бы одна виртуальная функция, то обязательно делаем виртуальный деструктор.


## Полиморфные контейнеры и клонирование

Полиморфным называется контейнер, состоящий из полиморфных объектов. То есть объектов, в составе которых есть виртуальные методы, переопределяемые в потомках.

Представим себе некий векторный графический редактор. Все фигуры будут наследоваться от класса `Shape`, с виртуальным методом `Draw()` — отображением фигуры на экран.

```cpp
class Shape
{
    virtual void Draw() {}
    virtual ~Shape() {}
};
```


Заведём полиморфный контейнер, хранящий все эти разновидности фигур. Полимофрный контейнер — контейнер указателей или ссылок на объекты базового класса. (Поэтому пишем `Shape*`).

```
vector<Shape*> v;
v.push_back(new Circle(20, 30, 5));
v.push_back(new Rectangle(10, 10, 20, 20));
    ...

// Отрисовываем
for (Shape* x : v)
    x -> Draw();

// Удаляем
for (Shape* x : v)
    delete x;  // разве нужно делать это вручную?

// попытка создать 
vector<Shape*> v1 = v;  // в v1 будут сидеть указатели на те же объекты
```

> Конструкторы в C++ не могут быть виртуальными.

```cpp
vector<Shape*> v1(v.size());
for (int i = 0; i < v.size(); i++)
    v1[i] = v[i]->clone();
```

Клонирование полиморфное, так как должен клонировать себя, а не объект базового типа. То есть Rectangle клонирует Rectangle, Circle клон. Circle, итд.

```cpp
class Shape
{
    virtual Shape* Clone() {}
};

class Circle : public Shape
{
    int x, y, z;

public:
    Circle(int xx, int yy, in zz) {}

    Shape * Clone()
    {
        return new Circle(x, y, z);
    }
}
```

Но Shape нужен только для того, чтобы его наследовать, методы в нём должны быть обязательно переопределены. Чтобы это чётко обозначить, пишем:

```cpp
class Shape {
    virtual void Draw() = 0;
}
```

Чисто виртуальные методы. Если не переорпделеить их, то получим ошибку.


## dynamic_cast

Если в классе имеются виртуальные методы, то для указателей и ссылок на него, можно использовать `dynamic_cast`.

Как это было в PascalABC.NET:

```delphi
var p : Person := new Student("Иванов", 20, 2, 9);
var s := p as Student;  // as пытается сделать downcast к Student, иначе nil.

if <> nil then
    s.get_group();
```

Но Страуструп придумал свою конструкцию, которая делает то же самое. Если приведение возможно, то вернёт ссылку на `Student`, иначе `nullptr`.

```cpp
Person * p = new Student("Иванов", 20, 2, 9);
Student * s = dynamic_cast<Student*>(p);

if (s != nullptr)
    s->get_group();
```
