# Лекция 18

Мощь STL заклчается в том, что алгоритмы ничего не знают про контейнеы, а контейнеры ниего не знают про алгоритмы. 
Для того, чтобы склеить контейнеры и алгоритмы в STL существуют итераторы.

Итератор это любой тип, к которому применимы операции:

* пробвижение: ++
* обращение к эдементу, на который указывает итератор: *
* проверка равентсва (==) и неравентсва (!=)


## Откуда брать итераторы

Рассмотрим использование итератора на примере массива:

```cpp
int a = {41, 42, 43};
int b[3];
copy(a, a + 3, b);
```

Если `a` и `b` объевленны в одном кадре стека, то правильнее написать так:

```cpp
int a = {41, 42, 43};
int b[sizeof(a)/sizeof(*a)];
copy(a, a + sizeof(a)/sizeof(*a), b);
```


А так итератор применяют со стандартным контейнером:

```cpp
vector<int> v1{1, 2, 3}, v2(3);
copy(v1.begin(), v1.end(), v2.begin());
```

Здесь `begin()` это итератор на первый элемент, а `end()` итератор на "элемент", следующий за последним.

### Итераторы в C++11

В С++11 работа с итераторами осуществляетс следующим образом:

std::copy(begin(a), end(a), begin(v));

Пример функции печати каждого элемента контейнера:

```cpp
void print(Cont const & c)
{
	for(auto it = begin(c), e = end(c); it != e; ++it)
		std::cout << *it << ' ';
	std::cout <<std::entl;
}
```

Эта функция нарушает философию STL тк в функцию передается контейнер, а не итераторы.

Рассмотрим использование `print`

```cpp
vector<int> v {1, 2, 3};
int a[] = {4, 5, 6};
print(v);
print(a);
```

Здесь функция `print` нормально отработает для вктора, но для массива она не должна сработать, т.к у массива нет `begin()` и `end()`. 
Однако для массива сработает слудующая специализация шаблона:

```cpp
template <class T, size_t N>
T* end(T(&arr)[N]);
```

Если имеется библиотечный тип `myvector` такой, что выполнены два условия:

* Не имеет функций-членов `begin`, `end`
* Мы не можем менять (добавить в него `begin` / `end`)

Тогда мы можем написать собственные версии свободных begin/end для этого типа и print станет работать и с ним.


## Концепты

Концептом(**concept**) называется именованный набор ограничений на параметры-типы, отраженный в документации или иным способом.

Предпринимаются попытки ввести концепты в язык, однако из-за большого количества неразрешенных моментов на сегодняшний день они безуспешны.


## Вложенные типы

```cpp
std::list<int> l {1, 2, 3};
std::list<int>::iterator it = l.begin();
```

```cpp
void f(std::list<int cons * l)
{
	std::list<int>::const_iterator it = l.begin(); 
}
```

Второй случай использовани typename

```cpp
template <typename Cont>
void print(Const const & c)
{
	for(typename Cont::const_iterator it = c.begin(), e = c.end; it != e; ++it)
		std::cout << *it << ' ';
	std::cout << std::endl;
}
```

Здесь typename говорит о том, что у нас статический класс.

```cpp
class myvector {
	template<typename T>
	class myv_it {
		T* cur;
	public:
		myv_it(T* cur): cur(cur) {}
		friend bool operator != (...) {...}
		void operator++() { ++cur; }
		T& operator*() {return *cur}
	}
myv_it begin() {return myv_it(data);}
myv_it end() {return myv_it(data + size);}
}
```