# Лекция 20

Рассмотрим другой `foreach`. Сначала напишем такую функцию:

```cpp
void twice (int & x)
{
	x *= 2;
}
``` 
```cpp
for_each(begin(v), end(v), twice)
// с помощю лямбд
for_each(begin(v), end(v), [](int& x){x *= 2;})
```

Теперь нам нужен `for_each`, который будет умножать элементы контейнера на произвольное число.

## Захват переменных из внешнего контекста

Изменим код `for_each` следующим образом

```cpp
for_each(begin(v), end(v), [](int& x){x *= a;})
```

Для того, что бы такой код откомпилировался нам необходимо указать в списке захвата, что переменная `a` пришла в функцию извне

```cpp
int a = 5;
for_each(begin(v), end(v), [=a](int& x){x *= a;})
```

`[=]` - все переменные, которые встретятся в теле лямбда функции захватываются по значению.

Лучше, если описание `int a` находится близко к `for_each`


## Сумма элементов контейнера с помощю `for_each`

```cpp
int sum = 0;
for_each(begin(v), end(v), [&sum](int x){sum += x;})
```

Как видим в списке захвата паявилась ссылка, поэтому теперь изменение `sum` в функции будет изменять значение этой переменной.

`[&]` - все переменные в теле лямбда, не являющиеся параметрами, захватываются по ссылке.

`[&, =x]` - все переменные в теле лямбда, кроме x, не являющиеся параметрами, захватываются по ссылке.

`[=, &sum]` - все переменные в теле лямбда, кроме x, не являющиеся параметрами, захватываются по значению.


## Объекты функции (функторы)

Лямбда функции с захваченными переменными переводятся объекты функций.

Создадим следующий класс:

```cpp
class SimHelper
{
public:
	int sum;
	SumHelper(): sum(0) {}
	void operator()(int x)
	{
		sum += x;
	}
}
```

На самом деле `f` в `for_each` это экземпляр класса, просто у этого класса перегружен `operator()`:

```cpp
auto f = for_each(begin(v), end(v), SumHelper())
cout << f.sum;
```

Объектом функции называется объект класса с перегруженной операцией `operator()`.


## Присваивание лямбда функций переменной.

```cpp
#include <functioanal>

auto g = [](int x){return x*x;}
// или так:
// std::function<int(int)> g = [](int x){return x*x;}
cout << g(5);
```

## Виды итераторов

* InIt
  ^
* OutIt
* FwdIt
  ^
* BidIt
  ^
* RanIt

Со всеми итераторами можно совершать следующие действия:

* `it1 == it2`, `it1 != it2`
* `it++`, `++it`
* `a = *it`

BidIt:

* `it--` `--it`

RanIt:

* `it[i]`
* `it1 < it2`, `it1 > it2`
* `it2 - it1 = n`
* `it+n` `it-n`

Название итератора это только договоренность 


### Алгоритм `find`

Работа:

```cpp
template<typename InIt, typename T>
InIt find(InIt b, InIt e, T t)
{
	while(b != e)
		if(*b == t)
			return b;
		++b;
	return b;
}
```

Использование:

```cpp
int a[]{3, 1, 5, 7}
auto it = find(begin(a), end(a), 5)
if (if != end(a))
	cout << "нашли" << *it;
else cout << "Нет";
```


### Алгоритм `find_if`

Работа:

```cpp
template<typename InIt, typename Pred>
InIt find_if(InIt b, InIt e, Pred p)
{
	while(b != e)
		if(p(*b))
			return b;
		++b;
	return b;
}
```

Предикат это то, что может быть вызано с одним параметром и вернет `bool`.


Использование:

```cpp
int a[]{3, 1, 5, 7}
auto it = find_if(begin(a), end(a), [](int x)->bool{return x%2 == 0})
if (if != end(a))
	cout << "нашли" << *it;
else cout << "Нет";
```