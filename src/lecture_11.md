# Лекция 11 


## Перегрузка унарных операций

Нам необходимо для класса Date выполнять d++ и ++d

### Префиксная унарная операция (общий случай)

@a

1. В виде функции-члена:
@a ~ a.operator@()

2. В виде внешней функции
@a ~ operator@(a)

Определим эту операцию для класса Date

```cpp
class Date
{
  …
  public:
  // определение префиксного ++
  Date& operator++()
  {
    add_days(1);
    return *this;
  }
};
```


### Постфиксная унарная операция

a@

a++ a--

До 98 года и префиксная постфиксная операции определялись одинаково. Для их разделения был введен фиктивный параметр.

1. В виде функции-члена
a@ ~ a.operator@(int)

2. В виде внешней функции
a@ ~ operator@(a, int)

```cpp
class Date
{
  …
  public:
  // определение префиксного ++
  // d++ возвращает значение до увеличения, знначит возвращать нужно копию, а не ссылку.
  Date operator++(int)
  {
    Date d = *this;
    add_days(1); // ++(*this);
    return d;
  }
};
```

Работа d++ выполняется дольше, поэтому надо выбирать в пользу ++d. Но это верно для своих типов, однако для встроенных типов компилятор производит оптимизацию и записи i++ и ++i равноценны.


## Перегрузка операции != 

```cpp
class Date
{
  …
  public:
  friend bool operator!=(const Date& d1, const Date& d2)
  {
    return !(d1==d2);
  }  
}
```

`d1!=d2` ~ `!(d1==d2)` ~ `!(d1.d == d2.d && d1.m == d2.m && d1.y == d2.y`



## Класс динамического массива

Попробуем реализовать аналог класса vector.

```cpp
template <typename T>
class myvector
{
  T* data;
  int sz;
  public:
  myvector(int size): sz(size)
  {
    data = new T[sz];
  }
  int size()
  {
    return sz;
  }
}
```

### Константные методы

```cpp
void print(const myvector<int> &v)
{
  for(int i =0 ; i<v.size();i++)
    cout << ...
}
```

Такой кон не откимпилируется т.к. метод size() петенциально может изменить состояние объекта.

Поэтому метод size надо определить как int size() const

## Перегрузка операции []


```cpp
template <typename T>
class myvector
{
  T* data;
  int sz;
  public:
  ...
  T& operator[](int n)
  {
    if(n < 0 || n >= sz)
      throw n;
    return date[n];
  }
}
```

`v[i]` ~ `v.operator[](i)` ~ `v.data[i]`

при вызове `cout << v.[i]` опять же не будет откомпилирован, поэтому необходимо определить вторую функцию 

```cpp
T operator[](int) const
{
  return data[n];
}
```


## Деструктор и его необходимость

Деструктор - коренная особеность C++

Рассмотрим такой случай

```cpp
{
  myvector<int> v(100000);
  v[0] = v[99999];
  ...
}
```

Возникает утечка памяти. 
Для борьбы с утечками память в таких случаях в C++ был придуман деструктор

```cpp
  ~myvector()
  {
    delete[] data;
  }
```

Деструкторы всега вызвваются неявно в определенный момент времени. Для локальных объектов при выходе из блока, а для глобальных при завершении программы.

Принципиально отличе этого подхода от сборщика  мусора: сборщик мусора вызывается в нетерменированный момент времени, а деструкторы всегда вызываются в детерминированный момент времени, когда заканчивается время жизни объекта.


Пример кода
{

}








###### Деструктор и его необходимость. В какой момент вызывается деструктор. Отличие от сборки мусора.
###### Сравнение объектов в динамической памяти в C++ и ссылок в .NET и Java
###### Конструктор копии и его необходимость. Стандартная функция copy для копирования диапазонов
###### Перегрузка операции присваивания.
###### 3 ситуации, в которых вызывается конструктор копии
