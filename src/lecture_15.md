# Лекция 15

## Перегрузка операций ввода-вывода

Займемся явной перегрузкой операции `operator<<()` для класса `frac`. В C++ в отличие от .NET перегружать нужно `operator<<()`, а не функцию преобразования класса к строке.

```cpp
class frac
{
	int m, n;
public:
	friend ostream& operator<<(ostream& os, const frac& f)
	{
		return os << '(' << f.m << ',' << f.n << ')';
	}
};
```

## Наследование

Наследование используется для повторного использования ранее написанного кода.

[img](Person(к, д, кк, op=)<-Student(univ, marks-динамич))

Наличие динамически выделяемой памяти в классе Student создает большое количество проблем. Рассмотрим подробнее:

```cpp
class Student: public Person
{
	string univ;	// Университет
	int* marks;		// Оценки
public:
	Student(const string& name, int age, const string& u, int pl, int ip, int ml) : Person(name, age), univ(u)
	{
		marks = newint[3];
		marks[0] = pl;
		marks[1] = ip;
		marks[2] = ml;
	}
	
	~Student() {delete[] marks;}
};                           |^ ~univ ~Person  
``` 

Person(name, age) // Вызов конструктора предка
Если не написать вызов Person(name, age), то произойдет вызов конструктора по умолчанию, а если его нет произойдет ошибка.


## Порядок вызова конструкторов и деструкторов

1. Вызов К базового класса
2. Вызов КК полей
3. Вызов К осн объекта
4. Вызов Д базового класса
5. Вызов ДД полей
6. Вызов Д предка

Этот порядок не изменится если поменять местами элементы списка инициализации Person(name, age) и univ(u)

Все это происходит в эпилоге предка

Теперь необходимо написать конструктор копии класса `Student` 

```cpp
Student(const Student& s) : Person(s), univ(s.univ)
{
	marks = new int[3];
	std::copy(s.maks, s.marks + 3, marks);
}
```

Person(s) будет работать корректно благодаря up-cast

Операция присваивания будет реализована несколько сложнее

```cpp
Student& operator=(const Student& s)
{
	if(&s != this)
	{
		delete[] marks;
		Person::operator=(s);
		marks = new int[3];
		std::copy(s.marks, s.marks + 3, marks);
		univ = s.univ;
	}
	returm *this;
};
```


Каждый ресурс под который выделяется память в конструкторе обычно стремятся обернуть объектом класса контролирующим этот ресурс, что упрощает код.

вручную       автоматически
int* marks -> vector<int> marks

Теперь код становится значительно проще

```cpp
class Student: public Person
{
	string univ;				// Университет
	vector<int> marks;	// Оценки
public:
	Student(const string& name, int age, const string& u, int pl, int ip, int ml) : Person(name, age), univ(u), marks(3)
	{
		marks[0] = pl;
		marks[1] = ip;
		marks[2] = ml;
	}
	// Деструктор теперь писать не надо
	// Автоматически сгенерируется
	// ~Student() // вызовет ~marks, ~uvin, ~Person
	// KK // вызовет КК предка, КК полей
	// operator= // вызовет operator= предка и operator= для всех полей
// Все это будет сделано автоматически
};
``` 

Вывод. Старайтесь все динамически выделяемые ресурсы оборачивать в отдельные классы


## Преобразование в иерархии "предок-потомок"

```cpp
Person p("Иванов", 20);
Student s("Петров", 19, 2, 9);

p = s;
s = p;
```

Здесь работает правило: переменной типа потомок можно присвоить переменную тип потомок, но не наоборот

[img]()

Однако в C++ размерно-объектная модель, поэтому вторая операция будет допустима.

|Иванов|20|
|Gtnhjd|19|2|9|

Произойдет копирование только полей связанных с персоной.

При присваивании объекта произв класса переменной базового класса происходит обрезание полей произв класса до полей базового класса.

```cpp
Person* pp = &p;
Student* ss = &s;
```
[img](pp->||, ss->|||)

pp = ss;
ss = pp;

Указателю на базовый класс можно присвоить адрес переменной произв класса, но не наоборот.

```cpp
Person& rp = s;
// rp дает доступ только к двум полям
```

Именно это используется в конструкторе копии Student

Student(const Student& s) : Person(s),...

