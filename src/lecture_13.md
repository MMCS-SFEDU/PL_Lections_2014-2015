#Лекция 13

## Метод resize() в `myvectror`

```cpp
#include <algorithm>

class myvector 
{
  ...
public:
  void resize(int nsz)
  {
    T* nd = new T[nsz];
    int n = (sz < nsn) ? sz : nsz;
    std::copy(data, data + n), nd);
    delete[] data;
    data = nd;
    sz = nsz;
  }
};
```


## Класс matrix

Матрица - вектор векторов. 

[img]()

Допустим нам необходимо создать матрицу 3x4, тогда мы можем реализовать ее следующим образом.

	myvector<myvectror<int>> m(3)

Эта строка на сработает т.к. мы не определили конструктор по умолчанию, поэтому необходимо добавить в класс `myvector` следующую строку.

	{
	myvectror(int size = 0);

Теперь мы имеем 3 экземпляра `myvector` с размером 0. Чтобы увеличить размерВыполним `resize()`

```cpp
for(int i =0; i < 3; i++)
  m[i].resize(4);

m[1][2] = 777;
}
```

В данном случае значение элементу будет  присваиваться по ссылке, поэтому передаваемый объект будет оччень маленьким

Рассмотрим, как данная матрица будет выглядеть в памяти.

[img]()

Будет ли данная динамическая память возвращена системе?

При выходе из блока `m[1][2] = 777; }`, будет вызван деструктор `~m() delete[] data`

`delete[] data`. Если `data` является массивом объектов нек класса, тогда до возврата своей памяти он вызывает деструкторы всех элементов этого массива. Т.е сначала будут освобождены массивы `int`, а за тем массив `data`.


## Реализация класса matrix

```cpp
/* matrix.hpp */
tmplate<typename T>
class matrix
{
  myvector<myvectror<T>> mdata;
  // Так сделать не получится 
  // myvector<myvectror<T>> mdata(3);
  
  
public:
  // вызывать конструктор mdata(m) в теле конструктора       
  // matrix уже поздно, а при объявлении еще рано, поэтому 
  // конструктор необходимо вызывать в списке инициализвции
  matrix(int m, int n): mdata(m)
  // 
  {
    for(int i =0; i < m; i++)
      mdata[i].resize(n);
  }
};
```

Если в списке инициалиции мы забыли вызвать конструктор подобъекта явл объектом другого класса, то сгенереируется код вызывающий конструктор этого объекта по умолчанию.

Деструктор для данного класса писать не надо. Будет сгенерирован дуструктор по умолчанию `~matrix() { }`.
Правило. деструкторы всех подобъектов вызываются автоматически в эпилоге (перед закрыванием фигурной скобки деструктором) деструктоПервым вызоветсяра основного объекта. 
Деструкторы вызываются в порядке обратном порядку вызова конструкторов. 

1. Конструктор подобъекта
2. Конструктор основного объекта
3. Деструктор осн объекта
4. Деструктор подъобъекта


### Операция доступа по индексу в matrix

В C++ так m[1, 2] писать нельзя
m[1][2] - [2] класс matrix не контролирует
Поэтому лучше всего перегрузить operator()
m(1, 2) ~ m.mdata[1][2] ~ m.mdata.data[1].data[2]

```cpp
/* matrix.hpp */
tmplate<typename T>
class matrix
{
  ...
  
public:
  ...
  T& operator()(int i, int j)
  {
    return mdata[i][j];
  }
  
};
``` 


## Конструктор копий и operator= для класса matrix

Их писать не нужно. Они сгенерируются автоматически и будут работать правильно. КК и operator= необходимо писать вручную, только если мы в конструкторе данного класса выделяем динамическую память, а в деструкторе ее явно возвращаем, а если в классе есть подобъект, которы берет на себя вс функции, то определять эти члены не нужно.

Как работают автоматически сгернерированныйе кк и операция присваивания?

Автоматически сгенерированный кк вызывает кк для всех своих полей. Автоматически сгенерированная операцияприсваивания вызывает операци присваивания для всех своих полей.

Посмотрим, какой будет сгенерирован кк 

```cpp
/* matrix.hpp */
tmplate<typename T>
class matrix
{    
public:
  ...
  matrix(const matrix<T> & mm): mdata(mm.mdata) {}
};
```


## Moving-конструкторы и moving-operator= (C++11)

```cpp
myvector<int> v(3), v1(3);
myvector<int> vv(v+v);
```

```cpp
template<typename T>
class myvectror
{
public:
  friend
  operator+(const myvectror<T>& v1, const myvectror<T>& v2) 
  {
    myvector<T> v(v1.sz);
    for(int i=0;i<v1.sz; i++)
      v[i] = v1[i] + v2[i]
    return v;
  }
}
```

Бьярн Страуструп предложил вынести RVO на уровень языка.

v+v1 - rvalue

Ссылка на rvalue T && t

```cpp
template<typename T>
class myvectror
{
public:
  myvector(const myvectro<T>&& v)
  {

  }
}
