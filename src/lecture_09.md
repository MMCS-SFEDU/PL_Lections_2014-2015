 
# Лекция 9

## Освобождение памяти занимаемой списком

```cpp
template <typename T>
void delete_list(node<T>* p)
{
  while(p)
  {
    auto p1 = p;
    p = p->next;
    delete p1;
  }
}
```  

Если этого не сделать, то список останется висеть в памяти (memory leak). Самое страшное это потерять указатель.

Если забыть освободить память, то после завершения программы, динамическая память будет принудительно возвращена системе. Однако так писать программы нельзя.

В сложных задачах, ручное освобождение памяти может представлять большую проблему.


## Векторы и строки(С++)

`char*` и `int[10]` к моменту создания C++ морально устарели, поэтому Бьярном Страуструпом были введены классы `string` и `vector<T>`.
 
У Страуструпа было несколько идей:

1. За то, что мы не используем, за то не платим.
2. Все новые средства работают столь же эффективно, как и старые средства.

### Работа со строками

```cpp
#include <string>

using namespace std;

s.size();	// Получить размер строки
string s1 = s;	// В этом случае s и s1 не разделяют общую память
s.substr(0, 2);	// 
s[i]		// Возможно обращение по индексу
s.insert(1, s1);//
s.erase(1, 2);
s.c_str()	// Преобразование к типу char*
s.find_first_of(s1)
s.find(s1)	// Поиск подстроки в строке
// если не найдено, то
// s.find(s1) == string::npos
```

#### Как передать строку в функцию

```cpp
void f(const string &s)
```

### Векторы

```cpp
#include <vector>

using namespace std;
 
vector<int> v(10) // Вектор их 10 нулей
```

```cpp
v[i]
```
Контроль выхода за границы массива реализована не была т.к. это привело бы к снижению производительности.

```cpp
v.size();
v.push_back(777); // Вставить новый элемент в конец
p.pop_back();	  // Удаление последнего элемента
```


#### Как вектор управляет памятью

Вектор выделяет чуть больше памяти чем ему требуется для  size элементов

```cpp
v.capacity() // Получить емкость
```

Как только **size** пытается превысить **capacity**, **capacity** увеличивается.

```cpp
v.resize(n)	// Изменить размер
v.reserve()	// Запросить новую емкость
```


Если выполняется условие `size > cap` тогда емкость увеличивается в 3 раза: `v.reserve(size*2)`.

В каждый момент времени память занимаемая вектором может быть в 2 раза больше его размера.

В процессе работы программы становится ясно, что в дальнейшем размер вектора увеличиваться не будет, тогда можно урезать емкость вектора до его размера.

```cpp
v.trim_to_size();
```


#### Что происходит, когда векторы присваиваются

При выполнении операции `v1 = v;` происходят следующие действия

1. Память занимаемая v1 уничтожается
2. v1 выделяется память размера v
3. Содержимое v копируется в v1

[img]()

#### Передача вектора в функцию

Если передавать в функцию собственно вектор: 

```cpp
void f(vector<int> v)
{
  ...
}
```

Тогда может происходить копирование большого объема данных. Чтобы избежать этого необходимо передавать вектор по ссылке: 

```cpp
// Передача вектора в функцию с возможностью его изменения
void f(vector<int> &v)
{
  ...
}

// Передача неизменяемого вектора в функцию
void f(const vector<int> &v)
{
  ...
}
```


## Классы и перегрузка операций

В языке С++ есть встроенные типы. Например

```cpp
int i;
double d;
```

При этом мы можем производить с ними привычные действия.

```cpp
d = 5.0; i = 3;
d = i * d;
```

При разработке языка Страуструп предложил идею, что все классы, должны быть аналогичны по возможностям встроенным типам.

**Отличие класса от структуры**, лишь в том, что в классе поля по-умолчанию *приватные*, а в структуре *публичные*.

#### Описание класса

Рассмотрим процесс создания класса на примере класса `Date`.
Описание самого класса необходимо помещать в `*.h` файл.

```cpp
/* date.h */

class Date
{
  private: // это слово писать не обязательно
    int y, m, d;
  
  public:
    // Конструктор класса
    Date(int d, int m, int y)
    {
      this->d = d;
      this->m = m;
      this->y = y;
    }
    void add_days(int n);
};
```


Все функции размещенные внутри класса автоматически помечаются модификатором `inline`.
 
Определение методов класса осуществляется в `*.cpp` файлах.

```cpp
/* date.cpp */

#include "date.h"

// Определение некоторой функции вне интерфейса класса
void Date::add_days(int n)
{
  ...
}
```

При надлежащей реализации класса `Data`, в C++ будут возможный действия следующего рода:

```cpp
Data d(17, 10, 14), d1 = d;
cin >> d1;
Date d2(31, 12, 14);

d += 7; // 
d1 = d1 - 7;
int n = d2 - d;
if(d == d1)...
d++; ++d; d1--; --d1;
d2++;
cout << d << ' ' << d1
```

Как видим это код выглядит так, будто `Data` это встроенный тип.


### Перегрузка бинарной операции

Перегрузка операции это описание операции с тем же именем, но работающей с другими типами.

@ - обозначение бинарной операции в рамках курса

Существует 2 способа

1.Как функцию-член

```cpp
a.operator@(b)
```

2.Как внешнюю функцию

```cpp
~operator@(a, b)
```

Реализовывать необходимо одно из двух. При попытке реализовать оба варианта компилятор выдаст ошибку.

```cpp
class Date
{

  ...

  void operator+=(int n)
  {
    add_days(n); // inline
  }
}
```

т.е. `d+= 7;` ~ `d.operator+=(7);` ~ `d.add_days(7);`