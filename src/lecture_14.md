# Лекция 14

## Moving-конструкторы и moving-operator= (C++11)

```cpp
/* main.cpp */
myvector<int> v(3), v1(3);
myvector<int> vv(v+v);
```

```cpp
/* myvector.h */
template<typename T>
class myvectror
{
public:
  friend
  myvector<T> operator+(const myvectror<T>& v1, const myvectror<T>& v2) 
  {
    myvector<T> v(v1.sz);
    for(int i=0;i<v1.sz; i++)
      v[i] = v1[i] + v2[i]
    return v;
  }
}
```

В стандарте **C++11** Бьярн Страуструп предложил вынести **RVO** на уровень языка.

`v+v1` - rvalue
мы не можем завписать `v1 + v2 = v`

Ссылка на rvalue `T && t`
 
Деструкторы для временных переменных вызываются в тот момент, когда эти переменные уже не используются для вычислений.

Вопрос в том, как уменьшить накладные расходы на копирование переменных.


```cpp
class myvector
{
  …
public:
  myvector(myvector<T>&& v)
  {
    sz = v.sz;
    data = v.data;
    v.data = nullptr;
  }

  // Переписываем деструктор
  ~myvector()
  {
    if(data != nullptr)
      delete[] data;
  }
}
```

`myvector<int> vv(v+v);`
Что выберет компилятор КК или moving-конструктор?

```cpp
class myvector
{
  …
public:
  myvector<T>& operator=(myvector<T>&& v)
  {
    if(data != nullptr)
      delete[] data;
    sz = v.sz;
    data = v.data;
    v.data = nullptr;
    return *this;
  }
}
```

Ввиду наличия большого количества стандартных классов использовать mooving-конструкторы приходится редко, однако знание такого механизма необходимо.


## Запрет генерации стандартных операторов

Как говорилось [ранее](12.html#member_funcs_generated_silently) существуют функции-члены, которые генерируются "молча", без явного описания. 
На практике, иногда, такие функции могут создать нежелательную функциональность, от которой нужно избавиться.

Для этих целей в C++ предусмотрен механизм запрета генерации стандартных конструкторов и функций. Рассмотрим его на примере класса `A`:

```cpp
class A
{
public:
	A(int i) {…}

	// Данная запись указывает на необходимость сгенерировать
	// конструктор по умолчанию
	A() = default;

	// Запретить генерацию конструктора по умолчанию
	A(const A&) = delete;

	// А так можно запретить генерацию operator=
	A& operator=(const A&) = delete; 
}  
```

## Класс frac дроби

Создадим новый класс `frac`, который реализует работу с рациональными дробями.

Экземпляр класса `frac` хранит число **f** в виде отношения **m/n**, где   **m**  и **n** целые числа типа `int`.

В данном классе необходимо реализовать преобразование объекта `frac` к типу `double`. То есть `frac f(1, 3);` будет эквивалентно `double d = 1/3.0;`

К примеру, если мы захотим создать функцию `Gauss`, которая решала бы уравнение вида **Ax = b** методом Гаусса, нам необходимо, чтобы эта функция могла работать с классом `frac`

```cpp
// T может быть равен double
// T может быть равен frac
template <typename T>
Gauss(const matrix<T> &A, const myvector<T> & b)
{
	…
}
```

Конструктор класса принимает в качестве аргументов значения чисел **m** и **n**, при этом логично хранить дроби в несократимом виде, поэтому разделим поля `m` и `n` на их наибольший общий делитель.

Реализация функции `operator+()` сводится к сложению двух отношений **m1/n1 + m2/n2**, при этом недопустимо прямое деление полей `m` и `n`, поэтому запишем формулу сложения дробей только с помощью операций сложения, умножения и целочисленного деления.
 
[img](формула m1/n1+m2/n2)

Важно помнить, что для нас важен порядок операций – результатом деления всегда должно быть целое число.

В итоге получим следующий код:

```cpp
class frac
{
	// n - натуральное
	// m - целое
	int m, n;
public:
	frac(int mm = 0, int nn = 1): m(mm), n(nn)
	{
		int nd = nod(m, n);
		m /= nd; n /= nd;
	}
	friend frac operator+(const frac f1, const frac f2)
	{
		int nd = nod(f1.n, f2.n);
		return frac(f2.n/nd*f1.m + f1.n/nd*f2.m, f1.n/nd*f2.n)
	}
	// реализовать operator*
}
```

<br><br>
Посмотрим на те возможности которые можно реализовать с помощью `frac`


## Конструктор преобразования

В реальной программе, работая с классом `frac`, мы хотим писать так: `frac f = 1;`.
То есть запись вида `f = 2;` должна быть эквивалентна `f = frac(2);`

Для решения этой задачи существует специальный конструктор, который называется конструктором преобразования.

Любой конструктор, который может быть вызван с одним параметром является конструктором преобразования и служит для неявного преобразования параметра к типу объекта данного класса. Это значит, что в нашем случае этот конструктор уже реализован. То есть запись `f = f1 + 3;` эквивалентна `f = f1 + frac(3);`, а `f = 2 * f2;` преобразуется к `f = frac(2) * f2;` ~ `f = frac(2,1) * f2;`

Однако обратим внимание на запись `frac(2) * f2`, здесь умножить целое число на дробь эффективнее, чем делать преобразование `frac(2,1)` и умножать дробь на дробь.

Поэтому, для ускорения работы перегрузим `operator*`:

```cpp
…
friend
frac operator*(int n, const frac &f)
{
	return frac(n * f.m, f.n);
}
…
```

#### Подвох в конструкторе с одним параметром (конструкторе преобразования)

Рассмотрим такой код:

```cpp
myvector<int> v(10), v1(10); // 10 нулей
v1 = v + 1;
```

Понятно, что делая запись `v1 = v + 1;` мы подразумеваем увеличение размера вектора на единицу и как следствие получение в `v1` нового вектора из 11 нулей.

На деле `v1 = v + 1;` эквивалентно `v1 = v + myvector<int>(10);`. То есть мы получим еще один вектор из 10 нулей.

Для того чтобы избежать данной ошибки, необходимо запретить преобразовывать **10** к `myvector<int>(10)`. Для этого существуют явные конструкторы преобразования.


### Явные конструкторы преобразования

Явный конструктор преобразования задается с помощью ключевого слова **explicit**, поэтому его еще называют **explicit**-конструктор.

```cpp
class myvector
{
	…
public:
	explicit myvector(int n) {}
}
```

Теперь компилятор запретит выражения типа `v1 = v + 1;`. Если же необходимо сложить два вектора, тогда надо явно указывать выполняемую операцию как `v1 = v + myvector<int>(10);`.


## Операции приведения типа

Часто при разработке новых классов появляется желание приводить уже существующие типы к новому, и наоборот. Попробуем написать следующий код:

```cpp
frac f = frac(2, 3);
double d = f;
```

В данном случае операция `double d = f` не сработает. Необходимо определить оператор приведения типа `operator double()`, для того, чтобы `f` была эквивалентна `double(f)`

```cpp
class frac
{
	int m, n;
public:
	operator double()
	{
		return m/(double)n;
	}
};
```

Теперь, в силу того, что `operator double()` является **inline**, запись `double d = f;` будет заменяться на `double d = f.m/(double)f.n;`