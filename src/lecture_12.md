# Лекция 12

 
## Функции-члены, которые генерируются "молча"

Рассмотрим класс `Empty`

```cpp
class Empty{

  public:
    Empty() {}

    Empty(Empty const &) {/* ... */}

    Empty & operator=(Empty const &) {/* ... */}

    ~Empty() {/* ... */}
};
```

Видим, что здесь приутствуют 4 функции:

* `Empty()` - конструктор по-умолчанию
* `Empty(Empty const &)` - конструктор копий
* `Empty & operator=(Empty const &)` - операция копирующего присваивания
* `~Empty()` - деструктор

Такое описание класса эквивалентно `class Empty {};`. Т.е эти 4 функции генерируются автоматически.


# Конструктор по-умолчанию

Конструктор по-умолчанию - конструктор без параметров, который генерируется автоматически, только тогда, кода не определено ни одного коструктора в классе.

Рассмотрим класс `Student`:

```cpp
class Student {
  string name;
public:
  Student(string const & name) : name(name){}
}
```

При попытке объявить экзепляр этого класса, компилятор выдаст ошибку.

```cpp
main(){
  Student s;
}
```

Это произойдет, из-за того, что после объявления конструктора `Student(string const & name) : name(name){}`, конструктор по-умоланию не был сгенерирован.

Аналогичная ошибка возникнет при попытке объявить массив типа `Student`.

## 3 слуая когда вызывается конструктор копий

1. `myvector myv2 = myv1`;
2. Вызов функции с передачей параметра по значению `void f(Student st) {/* ... */}`
3. Возвращение объекта по значению `Student g() {/* .. */}`

**Пример**

```cpp
myvector g() {return myvector();}

int main()
{
  myvector myv1 = g(); // случаи 1 + 3 -> 2кк
                       // Return Value Optimization -- RVO
} 
```

На самом деле запуск данного примера покажет, что во время выполнения программы не будет создано ни одного коструктора копий. Это результат работы оптимизирующего компилятора. Эта оптимизация производится подавляющим большинством современных компиляоров так как она определена в стандарте языка.

## Операция копирующего присваивания

```cpp
myvector & operator=(myvector const & other)
  {
    if(this != &other) {
      delete [] data;

      size = other.size;
      data = new int[size];
      copy(other.data, other.data + size, data);
      name = other.name;
      ++name[2];
    }
    
    return *this;
  }
```

## Идиома copy-and-swap

```cpp
void swap(myvector const & other)
{
  std::swap(data, other.data); 
  // Для всех полей
}
```